"""
GenDoc CLI - Beautiful API Documentation Generator
Supports Markdown, PDF, HTML, JSON (OpenAPI), and YAML (OpenAPI) export.
"""

import sys
import os
import datetime
import subprocess
import shutil
import json
import re
import html
from typing import Optional

try:
    import typer
except ImportError:
    print("\033[91mError: Typer is not installed. Please run: uv add typer\033[0m")
    sys.exit(1)

from parser import (
    scan_project,
    detect_schema_frameworks,
    find_generated_schemas,
    parse_schema_file,
)

# --- Optional Dependencies ---
try:
    import markdown

    MARKDOWN_AVAILABLE = True
except ImportError:
    MARKDOWN_AVAILABLE = False

try:
    from weasyprint import HTML, CSS

    WEASYPRINT_AVAILABLE = True
except ImportError:
    WEASYPRINT_AVAILABLE = False

try:
    import yaml

    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False

# Initialize Typer App
app = typer.Typer(
    name="GenDoc", help="Beautiful API Documentation Generator", add_completion=False
)


# --- CLI Colors ---
class Colors:
    HEADER = "\033[95m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


# --- Phase Loader ---
class ProgressBar:
    def __init__(self, total_phases=6, verbose=False):
        self.verbose = verbose

    def update(self, msg):
        if self.verbose:
            print(f"  {Colors.GREEN}[+]{Colors.ENDC} {msg}")
            return

        if msg.startswith("Phase"):
            # Clear previous active line
            sys.stdout.write("\r" + " " * 80 + "\r")
            sys.stdout.flush()

            # Format phase header
            # msg is like "Phase 1: Scanning views..."
            parts = msg.split(":", 1)
            if len(parts) > 1:
                # phase_name = parts[0].strip() # e.g. "Phase 1"
                description = parts[1].strip()
                print(f"{Colors.BOLD}{Colors.BLUE}:: {description}{Colors.ENDC}")
            else:
                print(f"{Colors.BOLD}{Colors.BLUE}:: {msg}{Colors.ENDC}")
        else:
            # Update detailed status on the same line
            sys.stdout.write(f"\r   {Colors.CYAN}└─{Colors.ENDC} {msg[:70]:<70}")
            sys.stdout.flush()

    def finish(self):
        if not self.verbose:
            sys.stdout.write("\r" + " " * 80 + "\r")  # Clear last detail line
            print(f"{Colors.BOLD}{Colors.GREEN}:: Scan Complete!{Colors.ENDC}")


def get_base_type(type_str):
    """Extracts base type from List[...] string."""
    if type_str.startswith("List[") and type_str.endswith("]"):
        return type_str[5:-1]
    return type_str


# --- OpenAPI Generation ---
def map_drf_type_to_openapi(drf_type):
    """Maps Django/DRF field types to OpenAPI types."""
    drf_type = drf_type.lower()

    if "int" in drf_type:
        return {"type": "integer"}
    elif "float" in drf_type or "decimal" in drf_type:
        return {"type": "number"}
    elif "bool" in drf_type:
        return {"type": "boolean"}
    elif "list" in drf_type:
        return {"type": "array", "items": {"type": "string"}}
    elif "dict" in drf_type or "json" in drf_type:
        return {"type": "object"}
    elif "datetime" in drf_type:
        return {"type": "string", "format": "date-time"}
    elif "date" in drf_type:
        return {"type": "string", "format": "date"}
    elif "uuid" in drf_type:
        return {"type": "string", "format": "uuid"}
    elif "email" in drf_type:
        return {"type": "string", "format": "email"}

    return {"type": "string"}


def generate_openapi_spec(specs, serializers_map):
    """Converts GenDoc scan results to OpenAPI 3.0 dictionary."""
    openapi = {
        "openapi": "3.0.2",
        "info": {
            "title": "Generated API Documentation",
            "version": "1.0.0",
            "description": "Auto-generated by GenDoc Static Analysis",
            "contact": {"name": "GenDoc"},
        },
        "paths": {},
        "components": {"schemas": {}},
    }

    # 1. Build Components (Schemas)
    for ser_name, ser_details in serializers_map.items():
        if not ser_name:
            continue

        schema = {"type": "object", "properties": {}, "required": []}

        for field_name, field_info in ser_details.get("fields", {}).items():
            field_type_raw = field_info.get("type", "string")
            props = field_info.get("props", [])

            # Check for nested serializer reference
            base_type = get_base_type(field_type_raw)
            field_schema = {}

            if base_type in serializers_map:
                field_schema = {"$ref": f"#/components/schemas/{base_type}"}
                if field_type_raw.startswith("List["):
                    field_schema = {"type": "array", "items": field_schema}
            else:
                field_schema = map_drf_type_to_openapi(field_type_raw)
                # Handle generic List[] of primitives
                if (
                    field_type_raw.startswith("List[")
                    and field_schema.get("type") != "array"
                ):
                    field_schema = {"type": "array", "items": {"type": "string"}}

            # Apply properties
            if "ReadOnly" in props:
                field_schema["readOnly"] = True
            if "WriteOnly" in props:
                field_schema["writeOnly"] = True
            if "Nullable" in props:
                field_schema["nullable"] = True
            if "Required" in props:
                schema["required"].append(field_name)

            schema["properties"][field_name] = field_schema

        if not schema["required"]:
            del schema["required"]

        openapi["components"]["schemas"][ser_name] = schema

    # 2. Build Paths
    for spec in specs:
        path = spec.get("path", "/")
        # Convert Django URL params <type:name> or <name> to OpenAPI {name}
        openapi_path = re.sub(r"<[^:>]+:([^>]+)>", r"{\1}", path)  # Matches <int:pk>
        openapi_path = re.sub(r"<([^>]+)>", r"{\1}", openapi_path)  # Matches <pk>

        if openapi_path not in openapi["paths"]:
            openapi["paths"][openapi_path] = {}

        for method, details in spec.get("methods", {}).items():
            method_lower = method.lower()

            operation = {
                "summary": f"{method} {path}",
                "description": spec.get("doc", "").strip(),
                "responses": {},
                "tags": [spec.get("view", "Default")],
            }

            # Add parameters from path
            path_params = re.findall(r"{([^}]+)}", openapi_path)
            if path_params:
                operation["parameters"] = []
                for param in path_params:
                    operation["parameters"].append(
                        {
                            "name": param,
                            "in": "path",
                            "required": True,
                            "schema": {"type": "string"},
                        }
                    )

            # Request Body
            req_ser = details.get("request")
            if req_ser and req_ser not in ["None", "Not required", "NoBody"]:
                base_req = get_base_type(req_ser)
                schema_ref = None

                if base_req in serializers_map:
                    schema_ref = {"$ref": f"#/components/schemas/{base_req}"}
                elif "RawBody" in req_ser:
                    schema_ref = {"type": "object", "description": "Raw JSON Body"}

                if schema_ref:
                    if req_ser.startswith("List["):
                        schema_ref = {"type": "array", "items": schema_ref}

                    operation["requestBody"] = {
                        "content": {"application/json": {"schema": schema_ref}}
                    }

            # Responses
            res_details = details.get("response_details")
            if res_details:
                for status, info in res_details.items():
                    ser = info.get("serializer")
                    response_obj = {"description": f"Status {status}"}

                    if ser and ser != "Unknown" and ser != "NoContent":
                        base_res = get_base_type(ser)
                        schema_ref = None

                        if base_res in serializers_map:
                            schema_ref = {"$ref": f"#/components/schemas/{base_res}"}
                        elif "Dynamic" in ser or "Object" in ser:
                            schema_ref = {"type": "object"}

                        if schema_ref:
                            if ser.startswith("List["):
                                schema_ref = {"type": "array", "items": schema_ref}

                            response_obj["content"] = {
                                "application/json": {"schema": schema_ref}
                            }

                    operation["responses"][status] = response_obj
            else:
                # Fallback response
                res_str = details.get("response", "None")
                operation["responses"]["200"] = {"description": f"Success: {res_str}"}

            openapi["paths"][openapi_path][method_lower] = operation

    return openapi


# --- Render Helpers (Markdown/HTML) ---
def render_nested_schema(serializer_name, serializers_map, visited=None):
    """Generates an HTML list for nested serializer fields."""
    if visited is None:
        visited = set()

    base_name = get_base_type(serializer_name)

    if base_name in visited:
        return "<em style='color: #888;'>(Recursive)</em>"

    if base_name not in serializers_map:
        return ""

    fields = serializers_map[base_name]["fields"]
    if not fields:
        return ""

    new_visited = visited.copy()
    new_visited.add(base_name)

    html_parts = [
        "\n<ul style='list-style-type: none; padding-left: 10px; margin: 0;'>\n"
    ]
    for fname, details in fields.items():
        ftype = details["type"]
        props = details["props"]

        prop_badges = []
        for p in props:
            color = (
                "#d9534f"
                if p == "Required"
                else "#5bc0de"
                if p == "ReadOnly"
                else "#aaa"
            )
            prop_badges.append(
                f"<span style='font-size: 0.8em; color: {color}; border: 1px solid {color}; padding: 0 4px; border-radius: 3px;'>{p}</span>"
            )

        prop_html = " ".join(prop_badges)

        child_base = get_base_type(ftype)
        nested_html = ""
        if child_base in serializers_map:
            child_content = render_nested_schema(
                child_base, serializers_map, new_visited
            )
            if child_content:
                nested_html = f"\n<div style='margin-left: 10px; border-left: 2px solid #eee; padding-left: 10px;'><details><summary style='cursor: pointer; color: #007bff;'>Show Nested</summary>{child_content}</details></div>\n"

        html_parts.append(
            f"<li style='margin-bottom: 4px;'><strong>{fname}</strong>: <code style='background: #f4f4f4; padding: 2px 4px; border-radius: 4px;'>{ftype}</code> {prop_html} {nested_html}</li>"
        )

    html_parts.append("</ul>\n")
    return "".join(html_parts)


def render_serializer_table_html(serializer_name, serializers_map):
    """Generates an HTML table (for PDF/HTML/DOC) - prevents alignment issues."""
    base_name = get_base_type(serializer_name)

    if base_name not in serializers_map:
        return ""

    fields = serializers_map[base_name]["fields"]
    if not fields:
        return ""

    lines = []
    lines.append("\n<table>")
    lines.append("  <thead>")
    lines.append("    <tr>")
    lines.append("      <th>Field</th>")
    lines.append("      <th>Type</th>")
    lines.append("      <th>Properties</th>")
    lines.append("      <th>Nested Schema</th>")
    lines.append("    </tr>")
    lines.append("  </thead>")
    lines.append("  <tbody>")

    visited = {base_name}

    for field_name, details in fields.items():
        ftype = details["type"]
        props_list = details["props"]

        # Format properties with badges
        if props_list:
            prop_badges = []
            for p in props_list:
                css_class = (
                    "prop-required"
                    if p == "Required"
                    else "prop-readonly"
                    if p == "ReadOnly"
                    else "prop-optional"
                )
                prop_badges.append(f'<span class="{css_class}">{p}</span>')
            props_html = " ".join(prop_badges)
        else:
            props_html = "-"

        # Check for nested serializer
        child_base = get_base_type(ftype)
        nested_display = "-"

        if child_base in serializers_map:
            nested_html = render_nested_schema(child_base, serializers_map, visited)
            if nested_html:
                nested_display = (
                    f"\n<details><summary>View</summary>{nested_html}</details>\n"
                )

        lines.append("    <tr>")
        lines.append(f"      <td><strong>{field_name}</strong></td>")
        lines.append(f"      <td><code>{ftype}</code></td>")
        lines.append(f"      <td>{props_html}</td>")
        lines.append(f"      <td>{nested_display}</td>")
        lines.append("    </tr>")

    lines.append("  </tbody>")
    lines.append("</table>\n")

    return "\n" + "\n".join(lines) + "\n"


def render_serializer_table_markdown(serializer_name, serializers_map):
    """Generates a Markdown table (for .md files)."""
    base_name = get_base_type(serializer_name)

    if base_name not in serializers_map:
        return ""

    fields = serializers_map[base_name]["fields"]
    if not fields:
        return ""

    lines = []
    lines.append("")
    lines.append("| Field | Type | Properties | Schema |")
    lines.append("| :--- | :--- | :--- | :--- |")

    visited = {base_name}

    for field_name, details in fields.items():
        ftype = details["type"]
        props = (
            ", ".join([f"`{p}`" for p in details["props"]]) if details["props"] else "-"
        )

        child_base = get_base_type(ftype)
        nested_display = "-"

        if child_base in serializers_map:
            nested_html = render_nested_schema(child_base, serializers_map, visited)
            if nested_html:
                nested_display = (
                    f"<details><summary>View Nested</summary>{nested_html}</details>"
                )

        lines.append(f"| **{field_name}** | `{ftype}` | {props} | {nested_display} |")

    return "\n" + "\n".join(lines) + "\n"


# --- JSON Mock Data Generator ---
def get_mock_value(ftype):
    """Returns a mock value for a given Django/DRF field type."""
    ftype = ftype.lower()
    if "int" in ftype:
        return 0
    if "float" in ftype or "decimal" in ftype:
        return 0.0
    if "bool" in ftype:
        return True
    if "uuid" in ftype:
        return "3fa85f64-5717-4562-b3fc-2c963f66afa6"
    if "datetime" in ftype:
        return "2024-02-15T12:00:00Z"
    if "date" in ftype:
        return "2024-02-15"
    if "email" in ftype:
        return "user@example.com"
    if "url" in ftype:
        return "https://example.com"
    if "json" in ftype or "dict" in ftype:
        return {"key": "value"}
    if "list" in ftype:
        return ["string"]
    return "string"


def generate_json_example(serializer_name, serializers_map, visited=None):
    """Generates a mock JSON dictionary/list for a serializer recursively."""
    if visited is None:
        visited = set()

    base_name = get_base_type(serializer_name)
    is_list = serializer_name.startswith("List[")

    # Handle infinite recursion
    if base_name in visited:
        return [{"...recursive..."}] if is_list else {"...recursive...": True}

    if base_name not in serializers_map:
        # If it's not a serializer (primitive or unknown), return mock value
        val = get_mock_value(base_name)
        return [val] if is_list else val

    fields = serializers_map[base_name]["fields"]
    if not fields:
        return [{}] if is_list else {}

    new_visited = visited.copy()
    new_visited.add(base_name)

    example_obj = {}
    for fname, details in fields.items():
        ftype = details["type"]

        # Determine if child is list
        child_is_list = ftype.startswith("List[")
        child_base = get_base_type(ftype)

        if child_base in serializers_map:
            # Recursively generate child
            val = generate_json_example(ftype, serializers_map, new_visited)
            example_obj[fname] = val
        else:
            # Primitive
            val = get_mock_value(child_base)
            if child_is_list:
                val = [val]
            example_obj[fname] = val

    return [example_obj] if is_list else example_obj


def render_json_block(serializer_name, serializers_map):
    """Renders a collapsible JSON example block."""
    try:
        example = generate_json_example(serializer_name, serializers_map)
        json_str = json.dumps(example, indent=2)
        return f"""
\n<details markdown="1">
<summary style="font-size: 0.9em; color: #6a737d;">View JSON Payload</summary>

```json
{json_str}
```

</details>\n
"""
    except Exception:
        return ""


def generate_markdown(specs, serializers_map, mode="md"):
    """
    Generate documentation content.
    mode: 'md', 'html', 'pdf'
    """
    lines = []

    use_html_tables = mode in ["html", "pdf"]
    use_static_headers = mode == "pdf"
    supports_json_view = mode in ["md", "html"]

    # Header
    generated_at = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    lines.append(f"# API Documentation")
    lines.append(f"> **Generated by GenDoc** on {generated_at}")
    lines.append("")

    # Group specs by Version -> Resource
    grouped_specs = {}  # {version: {resource: [specs]}}

    for spec in specs:
        path = spec["path"]
        # Regex to find /v1/, /v1.0/, /v2/ etc.
        match = re.search(r"/(v\d+(?:\.\d+)?)/", path)
        version = match.group(1) if match else "General"

        # Determine Resource (first segment after version)
        resource = "Other"
        if match:
            # path part after version match
            remainder = path[match.end() :]  # e.g. "auth/login" or "users/"
            parts = [p for p in remainder.split("/") if p]
            if parts:
                resource = parts[0].capitalize()  # e.g. "Auth"
        else:
            # If no version, use first segment
            parts = [p for p in path.split("/") if p]
            if parts:
                resource = parts[0].capitalize()

        if version not in grouped_specs:
            grouped_specs[version] = {}
        if resource not in grouped_specs[version]:
            grouped_specs[version][resource] = []

        grouped_specs[version][resource].append(spec)

    sorted_versions = sorted([v for v in grouped_specs.keys() if v != "General"])
    if "General" in grouped_specs:
        sorted_versions.append("General")

    # Executive Summary Table
    lines.append("## Executive Summary")
    lines.append("")

    for version in sorted_versions:
        # Sort resources within version
        resources = sorted(grouped_specs[version].keys())

        if len(sorted_versions) > 1:
            lines.append(f"### {version}")
        else:
            # If only one version (e.g. General), don't indent too much
            pass

        for resource in resources:
            version_specs = sorted(
                grouped_specs[version][resource], key=lambda x: x["path"]
            )

            lines.append(f"#### {resource}")
            lines.append("")

            if use_html_tables:
                # Use HTML table for PDF/HTML with proper styling
                lines.append('\n<table class="summary-table">')
                lines.append("  <thead>")
                lines.append("    <tr>")
                lines.append("      <th>Endpoint</th>")
                lines.append('      <th style="text-align: center;">Method</th>')
                lines.append("      <th>Request</th>")
                lines.append("      <th>Response</th>")
                lines.append("    </tr>")
                lines.append("  </thead>")
                lines.append("  <tbody>")

                for spec in version_specs:
                    path = spec["path"]
                    for method, details in spec["methods"].items():
                        req = details.get("request", "None")
                        res = details.get("response", "None")

                        # Truncate long responses
                        if len(res) > 60:
                            res = res[:57] + "..."

                        # Fix for PDF/HTML: Escape HTML characters
                        safe_path = html.escape(path)
                        safe_req = html.escape(req)
                        safe_res = html.escape(res)

                        method_class = f"method-{method.lower()}"
                        lines.append(f"    <tr>")
                        lines.append(f"      <td><code>{safe_path}</code></td>")
                        lines.append(
                            f'      <td style="text-align: center;"><span class="{method_class}">{method}</span></td>'
                        )
                        lines.append(f"      <td><code>{safe_req}</code></td>")
                        lines.append(f"      <td><code>{safe_res}</code></td>")
                        lines.append(f"    </tr>")

                lines.append("  </tbody>")
                lines.append("</table>\n")
            else:
                # Use Markdown table
                lines.append("| Endpoint | Method | Request | Response |")
                lines.append("| :--- | :---: | :--- | :--- |")

                method_styles = {
                    "GET": "color: #28a745;",
                    "POST": "color: #007bff;",
                    "PUT": "color: #fd7e14;",
                    "PATCH": "color: #ffc107;",
                    "DELETE": "color: #dc3545;",
                }

                for spec in version_specs:
                    path = spec["path"]
                    for method, details in spec["methods"].items():
                        req = details.get("request", "None")
                        res = details.get("response", "None").replace("|", "\\|")

                        style = method_styles.get(method, "")
                        method_badge = (
                            f"<span style='{style} font-weight: bold;'>{method}</span>"
                        )

                        lines.append(
                            f"| `{path}` | {method_badge} | `{req}` | `{res}` |"
                        )

            lines.append("")

    lines.append("---")
    lines.append("")

    # Endpoint Details

    # Logic to avoid "v1 Endpoints" header if only 1 version exists
    use_version_headers = len(sorted_versions) > 1

    if not use_version_headers:
        lines.append("## Endpoint Details")
        lines.append("")

    for version in sorted_versions:
        resources = sorted(grouped_specs[version].keys())

        if use_version_headers:
            lines.append(f"## {version} Endpoints")
            lines.append("")

        for resource in resources:
            version_specs = sorted(
                grouped_specs[version][resource], key=lambda x: x["path"]
            )

            lines.append(f"### {resource}")
            lines.append("")

            for spec in version_specs:
                path = spec["path"]
                view = spec["view"]
                doc = spec["doc"]

                lines.append(f"#### `{path}`")
                lines.append(f"**View Class:** `{view}`")
                lines.append("")

                if doc:
                    clean_doc = "\n".join(
                        [line.strip() for line in doc.split("\n") if line.strip()]
                    )
                    if clean_doc:
                        if use_html_tables:
                            lines.append(f"<blockquote>{clean_doc}</blockquote>")
                        else:
                            lines.append(f"```text\n{clean_doc}\n```")
                lines.append("")

                for method, details in spec["methods"].items():
                    if use_static_headers:
                        method_class = f"method-{method.lower()}"
                        lines.append(
                            f"<h5><span class='{method_class}'>{method}</span></h5>"
                        )
                    else:
                        # Added markdown="1" to details tag
                        lines.append(f'\n<details markdown="1">')
                        lines.append(f"<summary><strong>{method}</strong></summary>\n")

                    lines.append("")

                    # Input Section
                    req_ser = details.get("request", "None")

                    lines.append(f"**Input Parameters:**")

                    if req_ser not in ["None", "Not required", "NoBody"]:
                        lines.append(f"Schema: `{req_ser}`")
                        lines.append("")

                        base_req = get_base_type(req_ser)
                        if base_req in serializers_map:
                            if use_html_tables:
                                lines.append(
                                    render_serializer_table_html(
                                        req_ser, serializers_map
                                    )
                                )
                            else:
                                lines.append(
                                    render_serializer_table_markdown(
                                        req_ser, serializers_map
                                    )
                                )

                            # Add JSON View
                            if supports_json_view:
                                lines.append(
                                    render_json_block(req_ser, serializers_map)
                                )

                        elif "RawBody" in req_ser:
                            # Ensure newlines around blockquote
                            lines.append("")
                            lines.append(
                                "> **Raw Body:** This endpoint accepts raw JSON data."
                            )
                            lines.append("")
                    else:
                        lines.append("_No input required._")

                    lines.append("")

                    # Response Section
                    lines.append(f"**Responses:**")
                    lines.append("")

                    res_details = details.get("response_details")
                    if res_details:
                        for status, info in sorted(res_details.items()):
                            ser = info.get("serializer", "Unknown")
                            lines.append(f"**{status}** (`{ser}`)")

                            base_res = get_base_type(ser)
                            if base_res in serializers_map:
                                if use_html_tables:
                                    lines.append(
                                        render_serializer_table_html(
                                            ser, serializers_map
                                        )
                                    )
                                else:
                                    lines.append(
                                        render_serializer_table_markdown(
                                            ser, serializers_map
                                        )
                                    )

                                # Add JSON View
                                if supports_json_view:
                                    lines.append(
                                        render_json_block(ser, serializers_map)
                                    )
                            lines.append("")
                    else:
                        res_ser = details.get("response", "None")
                        lines.append(f"**Output:** `{res_ser}`")
                        lines.append("")

                        base_res = get_base_type(res_ser)
                        if base_res in serializers_map:
                            if use_html_tables:
                                lines.append(
                                    render_serializer_table_html(
                                        res_ser, serializers_map
                                    )
                                )
                            else:
                                lines.append(
                                    render_serializer_table_markdown(
                                        res_ser, serializers_map
                                    )
                                )

                            # Add JSON View
                            if supports_json_view:
                                lines.append(
                                    render_json_block(res_ser, serializers_map)
                                )

                    lines.append("")

                    if not use_static_headers:
                        lines.append("</details>\n")
                        lines.append("")

                lines.append("---")
                lines.append("")

    return "\n".join(lines)


def generate_schema(framework, root_dir):
    """Attempts to generate OpenAPI schema using detected framework."""
    manage_py = os.path.join(root_dir, "manage.py")
    if not os.path.exists(manage_py):
        print(f"{Colors.RED}Error: manage.py not found in {root_dir}{Colors.ENDC}")
        return None

    cmd = []
    output_file = "schema.yaml"

    if "drf-spectacular" in framework:
        cmd = [sys.executable, manage_py, "spectacular", "--file", output_file]
    elif "drf-yasg" in framework:
        output_file = "swagger.json"
        cmd = [sys.executable, manage_py, "generate_swagger", "-o", output_file]

    if not cmd:
        return None

    print(f"{Colors.BLUE}Running: {' '.join(cmd)}{Colors.ENDC}")
    try:
        subprocess.run(cmd, check=True, capture_output=True)
        print(f"{Colors.GREEN}Schema generated: {output_file}{Colors.ENDC}")
        return output_file
    except subprocess.CalledProcessError as e:
        print(f"{Colors.RED}Generation failed: {e.stderr.decode()}{Colors.ENDC}")
        return None


def convert_to_pdf(md_content, output_path):
    """Converts Markdown to PDF using WeasyPrint."""

    if not PYTHON_PDF_SUPPORT:
        print(f"{Colors.RED}Error: WeasyPrint not installed.{Colors.ENDC}")
        print(f"{Colors.YELLOW}Install: pip install markdown weasyprint{Colors.ENDC}")
        return False

    print(f"  {Colors.BLUE}[*]{Colors.ENDC} Converting to PDF with WeasyPrint...")

    try:
        # Convert MD -> HTML
        html_content = markdown.markdown(
            md_content, extensions=["tables", "fenced_code", "attr_list"]
        )

        # Enhanced CSS for PDF
        css = """
            @page {
                size: A4;
                margin: 2.5cm;
                @bottom-center {
                    content: "Page " counter(page);
                    font-size: 9pt;
                    color: #777;
                }
            }
            
            body {
                font-family: 'Helvetica', 'Arial', sans-serif;
                font-size: 11pt;
                line-height: 1.6;
                color: #333;
            }
            
            h1 { color: #2c3e50; border-bottom: 2px solid #2c3e50; padding-bottom: 10px; font-size: 24pt; page-break-after: avoid; }
            h2 { color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 30px; font-size: 18pt; page-break-after: avoid; }
            h3 { color: #34495e; margin-top: 25px; font-size: 15pt; font-weight: bold; page-break-after: avoid; }
            /* Increased size for Endpoint Paths */
            h4 { color: #34495e; font-size: 14pt; font-weight: bold; margin: 15px 0 10px 0; page-break-after: avoid; }
            
            /* Tables - General */
            table {
                border-collapse: collapse;
                width: 100%;
                margin: 15px 0;
                font-size: 10pt;
                page-break-inside: auto;
            }
            tr {
                page-break-inside: avoid;
                page-break-after: auto;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
                vertical-align: top;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }
            th {
                background-color: #f8f9fa;
                font-weight: bold;
                color: #333;
            }
            
            /* Summary Table - Specific styling */
            .summary-table {
                table-layout: fixed;
                width: 100%;
            }
            .summary-table th:nth-child(1) { width: 30%; }  /* Endpoint */
            .summary-table th:nth-child(2) { width: 12%; text-align: center; }  /* Method */
            .summary-table th:nth-child(3) { width: 28%; }  /* Request */
            .summary-table th:nth-child(4) { width: 30%; }  /* Response */
            
            .summary-table td {
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .summary-table td:nth-child(2) {
                text-align: center;
            }
            
            /* Page break utilities */
            .page-break-after {
                page-break-after: always;
            }
            .page-break-before {
                page-break-before: always;
            }
            .avoid-break {
                page-break-inside: avoid;
            }
            
            /* Code */
            code {
                background-color: #f4f4f4;
                font-family: 'Courier New', monospace;
                padding: 2px 4px;
                font-size: 10pt;
                border-radius: 3px;
                color: #e74c3c;
                word-break: break-all;
            }
            pre {
                background-color: #f8f9fa;
                padding: 15px;
                border-radius: 5px;
                border: 1px solid #eee;
                font-family: 'Courier New', monospace;
                font-size: 10pt;
                white-space: pre-wrap;
                margin: 15px 0;
                overflow-wrap: break-word;
            }
            pre code {
                background-color: transparent;
                padding: 0;
                color: #333;
            }
            
            blockquote {
                border-left: 4px solid #ddd;
                padding-left: 15px;
                margin: 15px 0;
                color: #666;
                font-style: italic;
            }
            
            /* Method badges */
            .method-get { background: #28a745; color: white; padding: 3px 10px; border-radius: 4px; font-weight: bold; font-size: 8pt; display: inline-block; }
            .method-post { background: #007bff; color: white; padding: 3px 10px; border-radius: 4px; font-weight: bold; font-size: 8pt; display: inline-block; }
            .method-put { background: #fd7e14; color: white; padding: 3px 10px; border-radius: 4px; font-weight: bold; font-size: 8pt; display: inline-block; }
            .method-patch { background: #ffc107; color: #333; padding: 3px 10px; border-radius: 4px; font-weight: bold; font-size: 8pt; display: inline-block; }
            .method-delete { background: #dc3545; color: white; padding: 3px 10px; border-radius: 4px; font-weight: bold; font-size: 8pt; display: inline-block; }
            
            /* Property badges */
            .prop-required { color: #d73a49; border: 1px solid #d73a49; padding: 1px 4px; border-radius: 3px; font-size: 8pt; font-weight: bold; }
            .prop-readonly { color: #0366d6; border: 1px solid #0366d6; padding: 1px 4px; border-radius: 3px; font-size: 8pt; font-weight: bold; }
            .prop-optional { color: #6a737d; border: 1px solid #6a737d; padding: 1px 4px; border-radius: 3px; font-size: 8pt; }
            
            /* Details */
            details {
                margin: 10px 0;
                padding: 10px;
                background: #f9f9f9;
                border: 1px solid #eee;
                border-radius: 4px;
            }
            summary {
                font-weight: bold;
                cursor: pointer;
                color: #0366d6;
            }
        """

        html_doc = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>API Documentation</title>
        </head>
        <body>
            {html_content}
        </body>
        </html>
        """

        HTML(string=html_doc).write_pdf(output_path, stylesheets=[CSS(string=css)])
        return True

    except Exception as e:
        print(f"{Colors.RED}PDF generation failed: {e}{Colors.ENDC}")
        return False


def convert_to_html(md_content, output_path):
    """Converts Markdown content to a standalone, interactive HTML file."""

    if not MARKDOWN_AVAILABLE:
        print(f"{Colors.RED}Error: Markdown library not installed.{Colors.ENDC}")
        print(f"{Colors.YELLOW}Install: uv add markdown{Colors.ENDC}")
        return False

    try:
        # Convert MD -> HTML using extensions for tables and structure
        # Added md_in_html to support markdown syntax inside HTML block tags like <details>
        html_body_content = markdown.markdown(
            md_content,
            extensions=[
                "tables",
                "fenced_code",
                "toc",
                "sane_lists",
                "attr_list",
                "md_in_html",
            ],
        )

        # Enhanced HTML5 Template
        html_doc = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>API Documentation</title>
            <style>
                :root {{
                    --sidebar-width: 280px;
                    --header-height: 60px;
                    --primary-color: #0366d6;
                    --bg-color: #ffffff;
                    --text-color: #24292e;
                    --border-color: #e1e4e8;
                }}
                
                body {{
                    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
                    margin: 0;
                    padding: 0;
                    color: var(--text-color);
                    background-color: var(--bg-color);
                    display: flex;
                    height: 100vh;
                    overflow: hidden;
                    font-size: 16px; /* Added explicit size */
                }}

                /* Sidebar */
                #sidebar {{
                    width: var(--sidebar-width);
                    background-color: #f6f8fa;
                    border-right: 1px solid var(--border-color);
                    overflow-y: auto;
                    padding: 20px;
                    flex-shrink: 0;
                    display: flex;
                    flex-direction: column;
                }}
                
                #sidebar h2 {{
                    font-size: 1.2em;
                    margin-top: 0;
                    padding-bottom: 10px;
                    border-bottom: 1px solid var(--border-color);
                }}

                .nav-link {{
                    display: block;
                    padding: 8px 0;
                    color: var(--text-color);
                    text-decoration: none;
                    font-size: 0.9em;
                    border-bottom: 1px solid transparent;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }}
                
                .nav-link:hover {{
                    color: var(--primary-color);
                    text-decoration: underline;
                }}

                /* Main Content */
                #main {{
                    flex-grow: 1;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                }}

                /* Header / Search Bar */
                #header {{
                    height: var(--header-height);
                    border-bottom: 1px solid var(--border-color);
                    padding: 0 30px;
                    display: flex;
                    align-items: center;
                    background-color: #fff;
                    flex-shrink: 0;
                    justify-content: space-between;
                }}

                #search-input {{
                    width: 300px;
                    padding: 8px 12px;
                    border: 1px solid var(--border-color);
                    border-radius: 6px;
                    font-size: 14px;
                }}
                
                .controls button {{
                    padding: 6px 12px;
                    margin-left: 10px;
                    border: 1px solid var(--border-color);
                    border-radius: 6px;
                    background: #f6f8fa;
                    cursor: pointer;
                    font-size: 13px;
                }}
                
                .controls button:hover {{
                    background-color: #e1e4e8;
                }}

                /* Content Area */
                #content {{
                    padding: 30px;
                    overflow-y: auto;
                    scroll-behavior: smooth;
                }}

                /* Endpoint Blocks (Created by JS) */
                .endpoint-block {{
                    margin-bottom: 30px;
                    border: 1px solid var(--border-color);
                    border-radius: 6px;
                    padding: 20px;
                }}
                
                .endpoint-block h3 {{
                    margin-top: 0;
                    padding-bottom: 10px;
                    border-bottom: 1px solid var(--border-color);
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    font-size: 1.5em; /* Increased Header Size */
                }}
                
                .endpoint-block h3:hover {{
                    color: var(--primary-color);
                }}
                
                .endpoint-block h3::after {{
                    content: "▼";
                    font-size: 0.7em;
                    margin-left: auto;
                    color: #999;
                }}
                
                .endpoint-block.collapsed h3::after {{
                    content: "◀";
                }}
                
                .endpoint-block.collapsed > *:not(h3) {{
                    display: none;
                }}
                
                /* Increase size for Endpoint Path headers in HTML */
                h4 {{
                    font-size: 1.3em;
                    margin-top: 1.5em;
                }}

                /* Tables & Code */
                table {{ border-collapse: collapse; width: 100%; margin: 15px 0; }}
                th, td {{ border: 1px solid #dfe2e5; padding: 6px 13px; }}
                th {{ background-color: #f6f8fa; font-weight: 600; }}
                code {{ background-color: rgba(27,31,35,0.05); padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; font-size: 85%; }}
                pre {{ background-color: #f6f8fa; border-radius: 3px; font-size: 85%; padding: 16px; overflow: auto; }}
                details {{ border: 1px solid #e1e4e8; border-radius: 6px; padding: 0.5em; margin-bottom: 1em; }}
                summary {{ font-weight: bold; cursor: pointer; }}
                
                h2 {{ margin-top: 40px; }}

                /* Highlight style */
                mark.highlight {{
                    background-color: #ffe066;
                    color: black;
                    border-radius: 2px;
                    padding: 0 2px;
                }}
                
            </style>
        </head>
        <body>
            <div id="sidebar">
                <h2>Endpoints</h2>
                <div id="nav-links"></div>
            </div>
            
            <div id="main">
                <div id="header">
                    <div style="font-weight: bold; font-size: 1.2em;">API Docs</div>
                    <div class="controls">
                        <input type="text" id="search-input" placeholder="Search endpoints...">
                        <button onclick="expandAll()">Expand All</button>
                        <button onclick="collapseAll()">Collapse All</button>
                    </div>
                </div>
                
                <div id="content">
                    {html_body_content}
                </div>
            </div>

            <script>
                document.addEventListener('DOMContentLoaded', () => {{
                    const content = document.getElementById('content');
                    const navLinksContainer = document.getElementById('nav-links');
                    
                    const headers = Array.from(content.querySelectorAll('h3'));
                    
                    headers.forEach(header => {{
                        const section = document.createElement('div');
                        section.className = 'endpoint-block';
                        
                        header.parentNode.insertBefore(section, header);
                        section.appendChild(header);
                        
                        let next = section.nextSibling;
                        while (next && next.tagName !== 'H3' && next.tagName !== 'H2' && next.tagName !== 'H1') {{
                            let sibling = next;
                            next = next.nextSibling;
                            section.appendChild(sibling);
                        }}
                        
                        header.addEventListener('click', () => {{
                            section.classList.toggle('collapsed');
                        }});
                        
                        const link = document.createElement('a');
                        link.className = 'nav-link';
                        link.textContent = header.textContent.replace(/`/g, '');
                        link.href = '#';
                        link.onclick = (e) => {{
                            e.preventDefault();
                            section.scrollIntoView({{ behavior: 'smooth' }});
                            section.style.borderColor = '#0366d6';
                            setTimeout(() => section.style.borderColor = '#e1e4e8', 2000);
                        }};
                        navLinksContainer.appendChild(link);
                    }});
                    
                    const searchInput = document.getElementById('search-input');
                    searchInput.addEventListener('keyup', (e) => {{
                        performSearch();
                    }});
                }});
                
                function expandAll() {{
                    document.querySelectorAll('.endpoint-block').forEach(b => b.classList.remove('collapsed'));
                    document.querySelectorAll('details').forEach(d => d.open = true);
                }}
                
                function collapseAll() {{
                    document.querySelectorAll('.endpoint-block').forEach(b => b.classList.add('collapsed'));
                    document.querySelectorAll('details').forEach(d => d.open = false);
                }}

                function performSearch() {{
                    const term = document.getElementById('search-input').value.toLowerCase();
                    const blocks = document.querySelectorAll('.endpoint-block');
                    const navs = document.querySelectorAll('.nav-link');
                    
                    // 1. Clear previous highlights
                    removeHighlights();

                    blocks.forEach((block, index) => {{
                        const text = block.textContent.toLowerCase();
                        const isMatch = !term || text.includes(term);
                        
                        // Show/Hide
                        block.style.display = isMatch ? 'block' : 'none';
                        if (navs[index]) navs[index].style.display = isMatch ? 'block' : 'none';

                        // 2. Highlight matching text and Expand
                        if (term && isMatch) {{
                             highlightText(block, term);
                             block.classList.remove('collapsed');
                        }}
                    }});
                }}

                function highlightText(element, term) {{
                     if (!term) return;
                     const regex = new RegExp(`(${{term.replace(/[.*+?^${{}}()|[\\]\\\\]/g, '\\\\$&')}})`, 'gi');
                     
                     function traverse(node) {{
                         if (node.nodeType === 3) {{ // Text node
                             const match = node.data.match(regex);
                             if (match) {{
                                 const fragment = document.createDocumentFragment();
                                 let lastIdx = 0;
                                 node.data.replace(regex, (match, p1, offset) => {{
                                     fragment.appendChild(document.createTextNode(node.data.slice(lastIdx, offset)));
                                     const mark = document.createElement('mark');
                                     mark.className = 'highlight';
                                     mark.textContent = match;
                                     fragment.appendChild(mark);
                                     lastIdx = offset + match.length;
                                     return match;
                                 }});
                                 fragment.appendChild(document.createTextNode(node.data.slice(lastIdx)));
                                 node.parentNode.replaceChild(fragment, node);
                             }}
                             return;
                         }}
                         
                         if (node.nodeType === 1 && node.tagName !== 'SCRIPT' && node.tagName !== 'STYLE' && node.tagName !== 'MARK') {{
                             Array.from(node.childNodes).forEach(traverse);
                         }}
                     }}
                     
                     traverse(element);
                }}

                function removeHighlights() {{
                    document.querySelectorAll('mark.highlight').forEach(mark => {{
                        const parent = mark.parentNode;
                        parent.replaceChild(document.createTextNode(mark.textContent), mark);
                        parent.normalize();
                    }});
                }}
            </script>
        </body>
        </html>
        """

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(html_doc)
        return True
    except Exception as e:
        print(f"{Colors.RED}HTML generation failed: {e}{Colors.ENDC}")
        return False


@app.command()
def generate_docs(
    target: str = typer.Argument(".", help="Project root or schema file"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Verbose output"),
    destination: Optional[str] = typer.Option(
        None, "--destination", "-d", help="Output file path"
    ),
    format: str = typer.Option(
        "md",
        "--format",
        "-f",
        help="Output format: 'md', 'pdf', 'html', 'json', 'yaml'",
    ),
    standard: bool = typer.Option(
        False, "--standard", "-s", help="Enforce standard paths (start with /v...)"
    ),
):
    """Generate API documentation from Django REST Framework project."""

    # Determine output filename and location
    if destination:
        output_file = destination
        # Ensure the directory for the provided destination exists
        output_dir = os.path.dirname(output_file)
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
    else:
        # Default to docs/ folder in current directory
        output_dir = "docs"
        os.makedirs(output_dir, exist_ok=True)
        output_file = os.path.join(output_dir, f"API_DOCS.{format}")

    print(f"{Colors.HEADER}╔════════════════════════════════════╗{Colors.ENDC}")
    print(f"{Colors.HEADER}║      GenDoc API Doc Generator      ║{Colors.ENDC}")
    print(f"{Colors.HEADER}╚════════════════════════════════════╝{Colors.ENDC}")

    specs = []
    serializers_map = {}
    used_schema = False

    # Schema file provided directly
    if os.path.isfile(target) and target.endswith((".json", ".yaml", ".yml")):
        print(f"\n{Colors.BLUE}Parsing schema file...{Colors.ENDC}")
        try:
            specs, serializers_map = parse_schema_file(target)
            used_schema = True
        except Exception as e:
            print(f"{Colors.RED}Error: {e}{Colors.ENDC}")
            raise typer.Exit(code=1)

    # Directory scan
    else:
        root_dir = target
        frameworks = detect_schema_frameworks(root_dir)
        schema_files = find_generated_schemas(root_dir)

        if frameworks or schema_files:
            print(f"\n{Colors.CYAN}--- Schema Detection ---{Colors.ENDC}")

            if frameworks:
                print(
                    f"Detected frameworks: {Colors.BOLD}{', '.join(frameworks)}{Colors.ENDC}"
                )

            if schema_files:
                print(f"Detected existing schema files:")
                for schema_file in schema_files:
                    print(f"  {Colors.YELLOW}- {schema_file}{Colors.ENDC}")

            print("-" * 24)

            if schema_files:
                print(f"{Colors.BOLD}Found existing schema file(s).{Colors.ENDC}")

                if frameworks:
                    choice = input(
                        f"Use existing ({Colors.GREEN}s{Colors.ENDC}), regenerate using {frameworks[0]} ({Colors.YELLOW}r{Colors.ENDC}), or use static analysis ({Colors.BLUE}g{Colors.ENDC})? [s/r/g]: "
                    ).lower()
                else:
                    choice = input(
                        f"Use existing schema ({Colors.GREEN}s{Colors.ENDC}) or static analysis ({Colors.BLUE}g{Colors.ENDC})? [s/g]: "
                    ).lower()

                if choice == "s":
                    print(f"{Colors.GREEN}Using:{Colors.ENDC} {schema_files[0]}")
                    try:
                        specs, serializers_map = parse_schema_file(schema_files[0])
                        used_schema = True
                    except Exception as e:
                        print(f"{Colors.RED}Error parsing schema: {e}{Colors.ENDC}")
                        print(
                            f"{Colors.YELLOW}Falling back to static analysis...{Colors.ENDC}"
                        )
                elif choice == "r" and frameworks:
                    generated_file = generate_schema(frameworks[0], root_dir)
                    if generated_file:
                        try:
                            specs, serializers_map = parse_schema_file(generated_file)
                            used_schema = True
                        except Exception as e:
                            print(
                                f"{Colors.RED}Error parsing generated schema: {e}{Colors.ENDC}"
                            )

            elif frameworks:
                print(
                    f"{Colors.YELLOW}Framework detected but no schema file found.{Colors.ENDC}"
                )
                choice = input(
                    f"Generate schema using {frameworks[0]} ({Colors.GREEN}y{Colors.ENDC}) or static analysis ({Colors.BLUE}g{Colors.ENDC})? [y/g]: "
                ).lower()
                if choice == "y":
                    generated_file = generate_schema(frameworks[0], root_dir)
                    if generated_file:
                        try:
                            specs, serializers_map = parse_schema_file(generated_file)
                            used_schema = True
                        except Exception as e:
                            print(
                                f"{Colors.RED}Error parsing generated schema: {e}{Colors.ENDC}"
                            )

    # Static analysis fallback
    if not used_schema:
        print(f"\n{Colors.BLUE}Scanning {target}...{Colors.ENDC}")
        pbar = ProgressBar(total_phases=6, verbose=verbose)
        specs, serializers_map = scan_project(target, callback=pbar.update)
        pbar.finish()

    # Apply Standard API Versioning if requested
    if standard:
        print(f"\n{Colors.BLUE}Standardizing API paths...{Colors.ENDC}")
        standardized_count = 0
        for spec in specs:
            path = spec["path"]
            # Find version pattern like /v1/ or /v1.0/
            match = re.search(r"/(v\d+(?:\.\d+)?)/", path)
            if match:
                # Strip everything before the version
                new_path = path[match.start() :]
                if new_path != path:
                    spec["path"] = new_path
                    standardized_count += 1

        if standardized_count > 0:
            print(
                f"{Colors.GREEN}Standardized {standardized_count} endpoint paths.{Colors.ENDC}"
            )

    # --- Export Logic ---
    if format == "json":
        print(f"\n{Colors.GREEN}[+]{Colors.ENDC} Generating JSON (OpenAPI)...")
        openapi_spec = generate_openapi_spec(specs, serializers_map)
        with open(output_file, "w") as f:
            json.dump(openapi_spec, f, indent=2)
        print(f"{Colors.BOLD}Successfully generated JSON spec.{Colors.ENDC}")
        print(f"Saved to: {Colors.UNDERLINE}{output_file}{Colors.ENDC}")
        return

    if format == "yaml":
        print(f"\n{Colors.GREEN}[+]{Colors.ENDC} Generating YAML (OpenAPI)...")
        if not YAML_AVAILABLE:
            print(
                f"{Colors.RED}Error: PyYAML is required for YAML export.{Colors.ENDC}"
            )
            print(f"{Colors.YELLOW}Run: uv add PyYAML{Colors.ENDC}")
            sys.exit(1)

        openapi_spec = generate_openapi_spec(specs, serializers_map)
        with open(output_file, "w") as f:
            yaml.dump(openapi_spec, f, sort_keys=False)
        print(f"{Colors.BOLD}Successfully generated YAML spec.{Colors.ENDC}")
        print(f"Saved to: {Colors.UNDERLINE}{output_file}{Colors.ENDC}")
        return

    # Normal Docs Generation (MD/PDF/HTML)
    print(f"\n{Colors.GREEN}[+]{Colors.ENDC} Generating content...")

    # Output
    if format == "html":
        md = generate_markdown(specs, serializers_map, mode="html")
        success = convert_to_html(md, output_file)
        if success:
            print(
                f"\n{Colors.BOLD}Successfully generated HTML documentation.{Colors.ENDC}"
            )
            print(f"Saved to: {Colors.UNDERLINE}{output_file}{Colors.ENDC}")
        return

    # Generate with format-specific rendering
    md = generate_markdown(specs, serializers_map, mode=format)

    if format == "pdf":
        success = convert_to_pdf(md, output_file)
        if not success:
            # Fallback to md if PDF conversion fails
            md_fallback = output_file.replace(".pdf", ".md")
            with open(md_fallback, "w") as f:
                f.write(md)
            print(
                f"\n{Colors.YELLOW}PDF generation failed. Saved as Markdown instead:{Colors.ENDC}"
            )
            print(f"Saved to: {Colors.UNDERLINE}{md_fallback}{Colors.ENDC}")
        else:
            # Also save markdown version
            md_version = output_file.replace(".pdf", ".md")
            md_content = generate_markdown(specs, serializers_map, mode="md")
            with open(md_version, "w") as f:
                f.write(md_content)

            print(
                f"\n{Colors.BOLD}Successfully generated documentation for {len(specs)} endpoints.{Colors.ENDC}"
            )
            print(
                f"{Colors.GREEN}PDF:{Colors.ENDC} {Colors.UNDERLINE}{output_file}{Colors.ENDC}"
            )
            print(
                f"{Colors.GREEN}Markdown:{Colors.ENDC} {Colors.UNDERLINE}{md_version}{Colors.ENDC}"
            )
    else:
        with open(output_file, "w") as f:
            f.write(md)
        print(
            f"\n{Colors.BOLD}Successfully generated documentation for {len(specs)} endpoints.{Colors.ENDC}"
        )
        print(f"Saved to: {Colors.UNDERLINE}{output_file}{Colors.ENDC}")


if __name__ == "__main__":
    app()
