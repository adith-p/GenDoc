import sys
import os
import datetime
from parser import scan_project, detect_schema_frameworks, find_generated_schemas


# --- CLI Colors ---
class Colors:
    HEADER = "\033[95m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


def get_base_type(type_str):
    """Extracts base type from List[...] string."""
    if type_str.startswith("List[") and type_str.endswith("]"):
        return type_str[5:-1]
    return type_str


def render_nested_schema(serializer_name, serializers_map, visited=None):
    """Generates an HTML list for nested serializer fields."""
    if visited is None:
        visited = set()

    base_name = get_base_type(serializer_name)

    # Avoid infinite recursion
    if base_name in visited:
        return "<em style='color: #888;'>(Recursive)</em>"

    if base_name not in serializers_map:
        return ""

    fields = serializers_map[base_name]["fields"]
    if not fields:
        return ""

    # Track recursion for children
    new_visited = visited.copy()
    new_visited.add(base_name)

    html_parts = ["<ul style='list-style-type: none; padding-left: 10px; margin: 0;'>"]
    for fname, details in fields.items():
        ftype = details["type"]
        props = details["props"]

        # Style properties
        prop_badges = []
        for p in props:
            color = "#666"
            if p == "Required":
                color = "#d9534f"
            elif p == "ReadOnly":
                color = "#5bc0de"
            elif p == "Optional":
                color = "#aaa"
            prop_badges.append(
                f"<span style='font-size: 0.8em; color: {color}; border: 1px solid {color}; padding: 0 4px; border-radius: 3px;'>{p}</span>"
            )

        prop_html = " ".join(prop_badges)

        # Check recursion for child fields
        child_base = get_base_type(ftype)
        nested_html = ""
        if child_base in serializers_map:
            child_content = render_nested_schema(
                child_base, serializers_map, new_visited
            )
            if child_content:
                nested_html = f"<div style='margin-left: 10px; border-left: 2px solid #eee; padding-left: 10px;'><details><summary style='cursor: pointer; color: #007bff;'>Show Nested Schema</summary>{child_content}</details></div>"

        html_parts.append(
            f"<li style='margin-bottom: 4px;'><strong>{fname}</strong>: <code style='background: #f4f4f4; padding: 2px 4px; border-radius: 4px;'>{ftype}</code> {prop_html} {nested_html}</li>"
        )

    html_parts.append("</ul>")
    return "".join(html_parts)


def render_serializer_table(serializer_name, serializers_map):
    """Generates a Markdown table for a serializer's fields."""
    base_name = get_base_type(serializer_name)

    if base_name not in serializers_map:
        return ""

    fields = serializers_map[base_name]["fields"]
    if not fields:
        return ""

    lines = []
    lines.append("")
    lines.append("| Field | Type | Properties | Schema |")
    lines.append("| :--- | :--- | :--- | :--- |")

    # Start visited set for recursion check
    visited = {base_name}

    for field_name, details in fields.items():
        ftype = details["type"]
        props = (
            ", ".join([f"`{p}`" for p in details["props"]]) if details["props"] else "-"
        )

        # Check for nested serializer
        child_base = get_base_type(ftype)
        nested_display = "-"

        if child_base in serializers_map:
            nested_html = render_nested_schema(child_base, serializers_map, visited)
            if nested_html:
                # Embed nested HTML list in the table cell
                nested_display = (
                    f"<details><summary>View Nested</summary>{nested_html}</details>"
                )

        lines.append(f"| **{field_name}** | `{ftype}` | {props} | {nested_display} |")

    return "\n" + "\n".join(lines) + "\n"


def generate_markdown(specs, serializers_map):
    lines = []

    # Header
    generated_at = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    lines.append(f"# API Documentation")
    lines.append(f"> **Generated by GenDoc** on {generated_at}")
    lines.append("")

    # Table of Contents
    lines.append("## Table of Contents")
    lines.append("")
    for spec in sorted(specs, key=lambda x: x["path"]):
        path = spec["path"]
        link = path.replace("/", "").replace("<", "").replace(">", "").replace(":", "")
        # Create anchor link
        anchor = (
            path.lower()
            .replace("/", "")
            .replace("<", "")
            .replace(">", "")
            .replace(":", "")
            .replace("_", "")
        )
        # lines.append(f"- [{path}](#{anchor})") # Simplified TOC

    # Executive Summary Table
    lines.append("## Executive Summary")
    lines.append("")
    lines.append("| Endpoint | Method | Request | Response |")
    lines.append("| :--- | :---: | :--- | :--- |")

    method_styles = {
        "GET": "color: #28a745;",
        "POST": "color: #007bff;",
        "PUT": "color: #fd7e14;",
        "PATCH": "color: #ffc107;",
        "DELETE": "color: #dc3545;",
    }

    for spec in sorted(specs, key=lambda x: x["path"]):
        path = spec["path"]
        # Escape path for table
        # path_link = f"[{path}](#{path.lower().replace('/', '').replace('<', '').replace('>', '').replace(':', '').replace('_', '')})"

        for method, details in spec["methods"].items():
            req = details.get("request", "None")
            res = details.get("response", "None")

            # Formatting
            style = method_styles.get(method, "")
            method_badge = f"<span style='{style} font-weight: bold;'>{method}</span>"

            res_fmt = res.replace("|", "\\|")
            req_fmt = req if req != "None" else "_(None)_"

            # Simplify Response for summary
            if len(res_fmt) > 50:
                res_fmt = res_fmt[:47] + "..."

            lines.append(f"| `{path}` | {method_badge} | `{req_fmt}` | `{res_fmt}` |")

    lines.append("")
    lines.append("---")
    lines.append("")

    # Endpoint Details
    lines.append("## Endpoint Details")
    lines.append("")

    for spec in sorted(specs, key=lambda x: x["path"]):
        path = spec["path"]
        view = spec["view"]
        doc = spec["doc"]

        lines.append(f"### `{path}`")
        lines.append(f"**View Class:** `{view}`")
        lines.append("")

        # Clean docstring indentation and add styling
        if doc:
            clean_doc = "\n".join(
                [line.strip() for line in doc.split("\n") if line.strip()]
            )
            if clean_doc:
                lines.append(f"```text\n{clean_doc}\n```")
        lines.append("")

        lines.append("#### Method Signatures")
        lines.append("")

        for method, details in spec["methods"].items():
            style = method_styles.get(method, "")
            method_badge = f"<span style='{style}'> {method}</span>"

            lines.append(f"<details>")
            lines.append(f"<summary><strong>{method_badge}</strong></summary>")
            lines.append("")

            # Input Section
            req_ser = details.get("request", "None")
            lines.append(f"#### Input Parameters")
            if req_ser != "None" and req_ser != "Not required":
                lines.append(f"**Schema:** `{req_ser}`")

                # Render field table if serializer found (handle List[] wrapper)
                base_req = get_base_type(req_ser)
                if base_req in serializers_map:
                    lines.append(render_serializer_table(req_ser, serializers_map))
                elif "RawBody" in req_ser:
                    lines.append("> **Raw Body:** This endpoint accepts raw JSON data.")
            else:
                lines.append("_No input required._")

            lines.append("")

            # Response Section
            lines.append(f"#### Responses")
            res_details = details.get("response_details")
            if res_details:
                for status, info in sorted(res_details.items()):
                    ser = info.get("serializer", "Unknown")

                    status_color = (
                        "#28a745"
                        if status.startswith("2")
                        else "#ffc107"
                        if status.startswith("4")
                        else "#dc3545"
                    )

                    lines.append(
                        f"**<span style='color: {status_color};'>{status}</span>** (`{ser}`)"
                    )

                    # Render field table if serializer found
                    base_res = get_base_type(ser)
                    if base_res in serializers_map:
                        lines.append(render_serializer_table(ser, serializers_map))
                    lines.append("")
            else:
                # Fallback for old/simple responses
                res_ser = details.get("response", "None")
                lines.append(f"**Output:** `{res_ser}`")

                base_res = get_base_type(res_ser)
                if base_res in serializers_map:
                    lines.append(render_serializer_table(res_ser, serializers_map))

            lines.append("")
            lines.append("</details>")
            lines.append("")

        lines.append("---")
        lines.append("")

    return "\n".join(lines)


def main():
    root_dir = sys.argv[1] if len(sys.argv) > 1 else "."

    print(f"{Colors.HEADER}╔════════════════════════════════════╗{Colors.ENDC}")
    print(f"{Colors.HEADER}║      GenDoc API Doc Generator      ║{Colors.ENDC}")
    print(f"{Colors.HEADER}╚════════════════════════════════════╝{Colors.ENDC}")

    # Check for existing schema frameworks & files
    frameworks = detect_schema_frameworks(root_dir)
    schema_files = find_generated_schemas(root_dir)

    if frameworks or schema_files:
        print(f"\n{Colors.CYAN}--- Schema Detection ---{Colors.ENDC}")
        if frameworks:
            print(
                f"Detected frameworks: {Colors.BOLD}{', '.join(frameworks)}{Colors.ENDC}"
            )
        if schema_files:
            print(f"Detected existing schema files:")
            for s in schema_files:
                print(f"  - {Colors.YELLOW}{s}{Colors.ENDC}")

        print("-" * 24)

        # Smart Prompt
        if schema_files:
            print(f"{Colors.BOLD}Found existing schema file(s).{Colors.ENDC}")
            choice = input(
                f"Do you want to use them ({Colors.GREEN}s{Colors.ENDC}) or use GenDoc static analysis ({Colors.BLUE}g{Colors.ENDC})? [s/g]: "
            ).lower()
            if choice == "s":
                print(
                    f"Using existing schema: {schema_files[0]} (Placeholder - parsing logic to be implemented)"
                )
                return
        else:
            print(
                f"{Colors.YELLOW}Framework detected but no schema file found.{Colors.ENDC}"
            )
            choice = input(
                f"Do you want to use GenDoc static analysis ({Colors.BLUE}g{Colors.ENDC}) or generate schema manually ({Colors.RED}q{Colors.ENDC})? [g/q]: "
            ).lower()
            if choice == "q":
                return

    print(f"\n{Colors.BLUE}Scanning {root_dir}...{Colors.ENDC}")

    def progress_callback(msg):
        print(f"  {Colors.GREEN}[+]{Colors.ENDC} {msg}")

    # Unpack both return values
    specs, serializers_map = scan_project(root_dir, callback=progress_callback)

    print(f"  {Colors.GREEN}[+]{Colors.ENDC} Generating Markdown...")
    # Pass serializers_map to generator
    md = generate_markdown(specs, serializers_map)

    with open("API_DOCS.md", "w") as f:
        f.write(md)

    print(
        f"\n{Colors.BOLD}Successfully generated documentation for {len(specs)} endpoints.{Colors.ENDC}"
    )
    print(f"Saved to: {Colors.UNDERLINE}API_DOCS.md{Colors.ENDC}")


if __name__ == "__main__":
    main()
